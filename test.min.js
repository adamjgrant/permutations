(()=>{const n=require("./permute_refactor");let e=[0,0];const t=(t,a,i)=>{const r=new n(i).permutations;return JSON.stringify(a)===JSON.stringify(r)?(e[0]++,`PASS: ${t}`):(e[1]++,`---FAIL: ${t}. Expected: ${a}, Actual: ${r}`)};let a=[{name:"Simple single string test",input:{main:["foo"]},expected:["foo"]},{name:"Array of two items",input:{main:["foo","bar"]},expected:["foo","bar"]},{name:"String, then array",input:{main:["foo",["bar","fizz"]]},expected:["foobar","foofizz"]},{name:"Array then array",input:{main:["foo","bar",["fizz","flop"]]},expected:"foofizz,fooflop,barfizz,barflop".split(",")},{name:"String, then array, then string",input:{main:["foo",["bar","fizz",["flop"]]]},expected:["foobarflop","foofizzflop"]},{name:"Array, then string, then array",input:{main:["foo","bar",["fizz",["buzz","flop"]]]},expected:"foofizzbuzz,foofizzflop,barfizzbuzz,barfizzflop".split(",")},{name:"Single item arrays",input:{main:["foo",["bar",["fizz"]]]},expected:["foobarfizz"]},{name:"Array then branch",input:{main:["foo",{branch:"something_else"}],something_else:["bar"]},expected:["foobar"]},{name:"Array then branch with array",input:{main:["foo",{branch:"something_else"}],something_else:["bar",["fizz"]]},expected:["foobarfizz"]},{name:"Array then branch with array, all arrays with multiple items",input:{main:["a","b",{branch:"something_else"}],something_else:["c","d",["e","f"]]},expected:"ace,acf,ade,adf,bce,bcf,bde,bdf".split(",")},{name:"Nested branches",input:{main:["a","b",{branch:"level1"}],level1:["c","d",{branch:"level2"}],level2:["e","f",["g"]]},expected:"aceg,acfg,adeg,adfg,bceg,bcfg,bdeg,bdfg".split(",")},{name:"Multiple branches on the same level",input:{main:["a","b",["c",{branch:"branch_a"}],["d",{branch:"branch_b"}]],branch_a:["e","f"],branch_b:["g","h"]},expected:"ace,acf,adg,adh,bce,bcf,bdg,bdh".split(",")},{name:"Array with multiple arrays",input:{main:["a",["b","c",["d"],"e","f",["g"]]]},expected:"abd,abg,acd,acg,aed,aeg,afd,afg".split(",")},{name:"Return values in branch references",input:{main:["",["a",{branch:"other",then:["x"]}],["b",{branch:"other",then:["y"]}]],other:["-"]},expected:"a-x,b-y".split(",")},{name:"Start branches without leaves",input:{main:[["a",["b","x"]],["c",["d","y"]]]},expected:"ab,ax,cd,cy".split(",")},{name:"Have branches lower down without leaves",input:{main:["p",[["a",["b","x"]],["c",["d","y"]]]]},expected:"pab,pax,pcd,pcy".split(",")},{name:"Use string as 'then' branch",input:{main:["a",{branch:"foo",then:"c"}],foo:["b"]},expected:["abc"]},{name:"Weird callback chaining",input:{main:["a",{branch:"foo",then:"c"}],foo:["b",{branch:"bar",then:"d"}],bar:["e"]},expected:["abedc"]},{name:"Callback chaining with stuff after it",input:{main:["a",{branch:"foo",then:"c"},["x","y"]],foo:["-"]},expected:"a-c,ax,ay".split(",")},{name:"idk, lol",input:{main:["a","b",["c","d",["e"],["f",["i","j",["k"]],"g",["h"]]],"z"]},expected:"ace,acfik,acfjk,acfh,acgik,acgjk,acgh,ade,adfik,adfjk,adfh,adgik,adgjk,adgh,bce,bcfik,bcfjk,bcfh,bcgik,bcgjk,bcgh,bde,bdfik,bdfjk,bdfh,bdgik,bdgjk,bdgh,zce,zcfik,zcfjk,zcfh,zcgik,zcgjk,zcgh,zde,zdfik,zdfjk,zdfh,zdgik,zdgjk,zdgh".split(",")},{name:"Branch linking with nested then redirection",input:{main:["A",{branch:"C",then:["D"]}],C:["F",{branch:"H",then:["K",["M"]]}],H:["J"]},expected:["AFJKMD"]},{name:"Branch nesting with two embedded redirects",input:{main:[{branch:"A",then:{branch:"D"}}],A:["a",{branch:"B",then:{branch:"C"}}],B:["b"],C:["c"],D:["d"]},expected:["abcd"]},{name:"Complex branch-then chaining",input:{main:["eocene",{branch:"everything-in-between",then:{branch:"holocene"}}],"everything-in-between":[{branch:"oligocene",then:["pliocene"]}],oligocene:["oligocene",{branch:"miocene"}],holocene:["holocene"],miocene:["miocene"]},expected:["eocene","oligocene","miocene","pliocene","holocene"].join("")},{name:"Bifurcated branch-then chaining",input:{main:[{branch:"middle-top",then:{branch:"double-middle-bottom"}}],"middle-top":["MT",{branch:"left",then:{branch:"middle-bottom"}},{branch:"right",then:{branch:"middle-bottom"}}],"middle-bottom":["MB"],left:["L"],right:["R"],"double-middle-bottom":["DMB"]},expected:["MTLMBDMB","MTRMBDMB"]}];a=a.slice(0,2),a.map((n,e)=>{return`${`#${e}. `}${(()=>{try{return t(n.name,n.expected,n.input)}catch(n){return`Error: ${n}`}})()}`}).forEach(n=>console.log(n));let i=[["Array with a branch is translated correctly",{main:["a",{branch:"B"}],B:["b"]},e=>{const t=new n(e);return JSON.stringify(t.translate_main)},JSON.stringify(["a",["b"]])],["Array with two branches is translated correctly",{main:["a",{branch:"B"},{branch:"C"}],B:["b"],C:["c"]},e=>{const t=new n(e);return JSON.stringify(t.translate_main)},JSON.stringify(["a",["b"],["c"]])],["Array with two branches, one with a child branch, is translated correctly",{main:["a",{branch:"B"},{branch:"C"}],B:["b",{branch:"D"}],C:["c"],D:["d"]},e=>{const t=new n(e);return JSON.stringify(t.translate_main)},JSON.stringify(["a",["b",["d"]],["c"]])],["Array with a branch and a then is translated correctly",{main:["a",{branch:"B",then:{branch:"C"}}],B:["b"],C:["c"]},e=>{const t=new n(e);return JSON.stringify(t.translate_main)},JSON.stringify(["a",["b",["c"]]])],["Array with a branch and a then with just an array is translated correctly",{main:["a",{branch:"B",then:["c"]}],B:["b"]},e=>{const t=new n(e);return JSON.stringify(t.translate_main)},JSON.stringify(["a",["b",["c"]]])],["Array with a branch and a then with just a string is translated correctly",{main:["a",{branch:"B",then:"c"}],B:["b"]},e=>{const t=new n(e);return JSON.stringify(t.translate_main)},JSON.stringify(["a",["b",["c"]]])]];e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["ab","b"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["","a"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["a","ac","b","bc"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc","ac"]),e=>{const t=new n(e,!0);return JSON.stringify(t.permutations)},JSON.stringify(["a"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abcd"]),e=>{const t=new n(e,!0);let a=0,i=[];for(;a++<100;)i.push(t.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["a.2b","ab","c"]);[...i].forEach((n,t)=>{const i=n[0],r=n[1],c=n[2],o=n[3],h=c(r);let b;h===o?(e[0]++,b=`PASS: ${i} | (${h})`):(e[1]++,b=`---FAIL: ${i}
      Expected: ${o}
      Actual:   ${h}`),console.log(`#${t+a.length}: ${b}`)}),console.log(`
${e[0]} Passing / ${e[1]} Failing`)})();