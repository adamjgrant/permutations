(()=>{const e=require("./permute");let n=[0,0];const a=(a,t,i)=>{const r=new e(i).permutations;return JSON.stringify(t)===JSON.stringify(r)?(n[0]++,`PASS: ${a}`):(n[1]++,`---FAIL: ${a}. Expected: ${t}, Actual: ${r}`)};let t=[{name:"Simple single string test",input:{main:["foo"]},expected:["foo"]},{name:"Array of two items",input:{main:["foo","bar"]},expected:["foo","bar"]},{name:"String, then array",input:{main:["foo",["bar","fizz"]]},expected:["foobar","foofizz"]},{name:"Array then array",input:{main:["foo","bar",["fizz","flop"]]},expected:"foofizz,fooflop,barfizz,barflop".split(",")},{name:"String, then array, then string",input:{main:["foo",["bar","fizz",["flop"]]]},expected:["foobarflop","foofizzflop"]},{name:"Array, then string, then array",input:{main:["foo","bar",["fizz",["buzz","flop"]]]},expected:"foofizzbuzz,foofizzflop,barfizzbuzz,barfizzflop".split(",")},{name:"Single item arrays",input:{main:["foo",["bar",["fizz"]]]},expected:["foobarfizz"]},{name:"Array then branch",input:{main:["foo",{branch:"something_else"}],something_else:["bar"]},expected:["foobar"]},{name:"Array then branch with array",input:{main:["foo",{branch:"something_else"}],something_else:["bar",["fizz"]]},expected:["foobarfizz"]},{name:"Array then branch with array, all arrays with multiple items",input:{main:["a","b",{branch:"something_else"}],something_else:["c","d",["e","f"]]},expected:"ace,acf,ade,adf,bce,bcf,bde,bdf".split(",")},{name:"Nested branches",input:{main:["a","b",{branch:"level1"}],level1:["c","d",{branch:"level2"}],level2:["e","f",["g"]]},expected:"aceg,acfg,adeg,adfg,bceg,bcfg,bdeg,bdfg".split(",")},{name:"Multiple branches on the same level",input:{main:["a","b",["c",{branch:"branch_a"}],["d",{branch:"branch_b"}]],branch_a:["e","f"],branch_b:["g","h"]},expected:"ace,acf,adg,adh,bce,bcf,bdg,bdh".split(",")},{name:"Array with multiple arrays",input:{main:["a",["b","c",["d"],"e","f",["g"]]]},expected:"abd,abg,acd,acg,aed,aeg,afd,afg".split(",")},{name:"Return values in branch references",input:{main:["",["a",{branch:"other",then:["x"]}],["b",{branch:"other",then:["y"]}]],other:["-"]},expected:"a-x,b-y".split(",")},{name:"Start branches without leaves",input:{main:[["a",["b","x"]],["c",["d","y"]]]},expected:"ab,ax,cd,cy".split(",")},{name:"Have branches lower down without leaves",input:{main:["p",[["a",["b","x"]],["c",["d","y"]]]]},expected:"pab,pax,pcd,pcy".split(",")},{name:"Use string as 'then' branch",input:{main:["a",{branch:"foo",then:"c"}],foo:["b"]},expected:["abc"]},{name:"Weird callback chaining",input:{main:["a",{branch:"foo",then:"c"}],foo:["b",{branch:"bar",then:"d"}],bar:["e"]},expected:["abedc"]},{name:"Callback chaining with stuff after it",input:{main:["a",{branch:"foo",then:"c"},["x","y"]],foo:["-"]},expected:"a-c,ax,ay".split(",")},{name:"idk, lol",input:{main:["a","b",["c","d",["e"],["f",["i","j",["k"]],"g",["h"]]],"z"]},expected:"ace,acfik,acfjk,acfh,acgik,acgjk,acgh,ade,adfik,adfjk,adfh,adgik,adgjk,adgh,bce,bcfik,bcfjk,bcfh,bcgik,bcgjk,bcgh,bde,bdfik,bdfjk,bdfh,bdgik,bdgjk,bdgh,zce,zcfik,zcfjk,zcfh,zcgik,zcgjk,zcgh,zde,zdfik,zdfjk,zdfh,zdgik,zdgjk,zdgh".split(",")},{name:"Branch linking with nested then redirection",input:{main:["A",{branch:"C",then:["D"]}],C:["F",{branch:"H",then:["K",["M"]]}],H:["J"]},expected:["AFJKMD"]},{name:"Branch nesting with two embedded redirects",input:{main:[{branch:"A",then:{branch:"D"}}],A:["a",{branch:"B",then:{branch:"C"}}],B:["b"],C:["c"],D:["d"]},expected:["abcd"]},{name:"Complex branch-then chaining",input:{main:["eocene",{branch:"everything-in-between",then:{branch:"holocene"}}],"everything-in-between":[{branch:"oligocene",then:["pliocene"]}],oligocene:["oligocene",{branch:"miocene"}],holocene:["holocene"],miocene:["miocene"]},expected:["eocene","oligocene","miocene","pliocene","holocene"].join("")}];t.map((e,n)=>{return`${`#${n}. `}${(()=>{try{return a(e.name,e.expected,e.input)}catch(e){return`Error: ${e}`}})()}`}).forEach(e=>console.log(e)),[["Gracefully handle empty strings",{main:["a","",["b"]]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["ab","b"])],["Gracefully handle empty strings #2",{main:["a",""]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["","a"])],["Gracefully handle empty strings #2",{main:["a","b",["","c"]]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["a","ac","b","bc"])],["Gracefully handle empty strings #3",{main:["a",["","b",["c"]]]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc","ac"])],["Gracefully handle empty strings #3",{main:["a",[""]]},n=>{const a=new e(n,!0);return JSON.stringify(a.permutations)},JSON.stringify(["a"])],["Nested thens handled until the final then of the parent calling branch",{main:[{branch:"A",then:{branch:"C"}}],A:["a",[{branch:"B"}]],B:["b"],C:["c"]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc"])],["(#2) Nested thens handled until the final then of the parent calling branch",{main:[{branch:"A",then:{branch:"C"}}],A:["a",{branch:"B"}],B:["b"],C:["c"]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc"])],["Branch nesting with two embedded redirects (random permutations)",{main:[{branch:"A",then:{branch:"D"}}],A:["a",{branch:"B",then:{branch:"C"}}],B:["b"],C:["c"],D:["d"]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abcd"])],["Two branches in the top-level array",{main:[{branch:"a",then:{branch:"b"}},{branch:"c"}],a:["a","a.2"],b:["b"],c:["c"]},n=>{const a=new e(n,!0);let t=0,i=[];for(;t++<100;)i.push(a.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["a.2b","ab","c"])]].forEach((e,a)=>{const i=e[0],r=e[1],c=e[2],o=e[3],h=c(r);let b;h===o?(n[0]++,b=`PASS: ${i} | (${h})`):(n[1]++,b=`---FAIL: ${i}
      Expected: ${o}
      Actual:   ${h}`),console.log(`#${a+t.length}: ${b}`)}),console.log(`
${n[0]} Passing / ${n[1]} Failing`)})();