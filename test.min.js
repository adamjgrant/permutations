(()=>{const e=require("./permute"),a=(a,n,t)=>{const i=new e(t).permutations;return JSON.stringify(n)===JSON.stringify(i)?`PASS: ${a}`:`FAIL: ${a}. Expected: ${n}, Actual: ${i}`};let n=[{name:"Simple single string test",input:{main:["foo"]},expected:["foo"]},{name:"Array of two items",input:{main:["foo","bar"]},expected:["foo","bar"]},{name:"String, then array",input:{main:["foo",["bar","fizz"]]},expected:["foobar","foofizz"]},{name:"Array then array",input:{main:["foo","bar",["fizz","flop"]]},expected:"foofizz,fooflop,barfizz,barflop".split(",")},{name:"String, then array, then string",input:{main:["foo",["bar","fizz",["flop"]]]},expected:["foobarflop","foofizzflop"]},{name:"Array, then string, then array",input:{main:["foo","bar",["fizz",["buzz","flop"]]]},expected:"foofizzbuzz,foofizzflop,barfizzbuzz,barfizzflop".split(",")},{name:"Single item arrays",input:{main:["foo",["bar",["fizz"]]]},expected:["foobarfizz"]},{name:"Array then branch",input:{main:["foo",{branch:"something_else"}],something_else:["bar"]},expected:["foobar"]},{name:"Array then branch with array",input:{main:["foo",{branch:"something_else"}],something_else:["bar",["fizz"]]},expected:["foobarfizz"]},{name:"Array then branch with array, all arrays with multiple items",input:{main:["a","b",{branch:"something_else"}],something_else:["c","d",["e","f"]]},expected:"ace,acf,ade,adf,bce,bcf,bde,bdf".split(",")},{name:"Nested branches",input:{main:["a","b",{branch:"level1"}],level1:["c","d",{branch:"level2"}],level2:["e","f",["g"]]},expected:"aceg,acfg,adeg,adfg,bceg,bcfg,bdeg,bdfg".split(",")},{name:"Multiple branches on the same level",input:{main:["a","b",["c",{branch:"branch_a"}],["d",{branch:"branch_b"}]],branch_a:["e","f"],branch_b:["g","h"]},expected:"ace,acf,adg,adh,bce,bcf,bdg,bdh".split(",")},{name:"Array with multiple arrays",input:{main:["a",["b","c",["d"],"e","f",["g"]]]},expected:"abd,abg,acd,acg,aed,aeg,afd,afg".split(",")},{name:"Return values in branch references",input:{main:["",["a",{branch:"other",then:["x"]}],["b",{branch:"other",then:["y"]}]],other:["-"]},expected:"a-x,b-y".split(",")},{name:"Start branches without leaves",input:{main:[["a",["b","x"]],["c",["d","y"]]]},expected:"ab,ax,cd,cy".split(",")},{name:"Have branches lower down without leaves",input:{main:["p",[["a",["b","x"]],["c",["d","y"]]]]},expected:"pab,pax,pcd,pcy".split(",")},{name:"Use string as 'then' branch",input:{main:["a",{branch:"foo",then:"c"}],foo:["b"]},expected:["abc"]},{name:"Weird callback chaining",input:{main:["a",{branch:"foo",then:"c"}],foo:["b",{branch:"bar",then:"d"}],bar:["e"]},expected:["abed","abc"]},{name:"Callback chaining with stuff after it",input:{main:["a",{branch:"foo",then:"c"},["x","y"]],foo:["-"]},expected:"a-c,ax,ay".split(",")},{name:"idk, lol",input:{main:["a","b",["c","d",["e"],["f",["i","j",["k"]],"g",["h"]]],"z"]},expected:"ace,acfik,acfjk,acfh,acgik,acgjk,acgh,ade,adfik,adfjk,adfh,adgik,adgjk,adgh,bce,bcfik,bcfjk,bcfh,bcgik,bcgjk,bcgh,bde,bdfik,bdfjk,bdfh,bdgik,bdgjk,bdgh,zce,zcfik,zcfjk,zcfh,zcgik,zcgjk,zcgh,zde,zdfik,zdfjk,zdfh,zdgik,zdgjk,zdgh".split(",")},{name:"Branch linking with nested then redirection",input:{main:["A",{branch:"C",then:["D"]}],C:["F",{branch:"H",then:["K",["M"]]}],H:["J"]},expected:["AFJKMD"]}];n.pop(),n.map((e,n)=>{return`${`#${n}. `}${(()=>{try{return a(e.name,e.expected,e.input)}catch(e){return`Error: ${e}`}})()}`}).forEach(e=>console.log(e)),[["Gracefully handle empty strings",{main:["a","",["b"]]},a=>{const n=new e(a,!0);let t=0,i=[];for(;t++<100;)i.push(n.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["ab","b"])],["Gracefully handle empty strings #2",{main:["a",""]},a=>{const n=new e(a,!0);let t=0,i=[];for(;t++<100;)i.push(n.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["","a"])],["Gracefully handle empty strings #2",{main:["a","b",["","c"]]},a=>{const n=new e(a,!0);let t=0,i=[];for(;t++<100;)i.push(n.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["a","ac","b","bc"])],["Gracefully handle empty strings #3",{main:["a",["","b",["c"]]]},a=>{const n=new e(a,!0);let t=0,i=[];for(;t++<100;)i.push(n.permutations[0]);return JSON.stringify([...new Set(i)].sort())},JSON.stringify(["abc","ac"])],["Gracefully handle empty strings #3",{main:["a",[""]]},a=>{const n=new e(a,!0);return JSON.stringify(n.permutations)},JSON.stringify(["a"])]].forEach((e,a)=>{const n=e[0],t=e[1],i=e[2],r=e[3],c=i(t);let f;f=c===r?`PASS: ${n} | (${c})`:`FAIL: ${n}
      Expected: ${r}
      Actual:   ${c}`,console.log(f)})})();