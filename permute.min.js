class Tree{constructor(n){this.object=n}get one(){return this.translated_branch.one()}get permutations(){return this.translated_branch.terminal_leaves()}get translated_branch(){return new Branch(this,this.translate_main)}get translate_main(){return new Branch(this,this.object.main).translate_object}branch(n){return this.object[n]||[]}}class Branch{constructor(n,e,t){this.tree=n,this.object=e,this.then_branches=t}terminal_leaves(n=""){return this.branches().length?this.leaves().reduce((e,t)=>{return e.concat(this.branches().reduce((e,r)=>{return e.concat(new Branch(this.tree,r).terminal_leaves(`${n}${t}`))},[]))},[]):this.leaves().map(e=>`${n}${e}`)}one(n=""){const e=`${n}${this.leaves(!0)}`;return this.branches().length?new Branch(this.tree,this.branches(!0)).one(e):e}leaves(n=!1){let e=this.object.filter(n=>new Leaf(n).is_string)||[];const t=e.length?e:[""];return n?t[~~(t.length*Math.random())]:t}branches(n=!1){const e=this.object.filter(n=>new Leaf(n).is_branch);return n?e[~~(e.length*Math.random())]:e}get translate_object(){console.log(`Then branches for branch ${JSON.stringify(this.object)}: ${this.then_branches}`);const n=new Leaf(this.object);return n.is_branch_reference?this.translate_branch_reference(n):(this.is_terminal_branch&&void 0!==this.then_branches&&this.object.push(this.then_branches),this.object.map(n=>{const e=new Leaf(n);if(e.is_branch_reference)return this.translate_branch_reference(e);if(e.is_branch){const n=new Branch(this.tree,e.node);return n.is_terminal_branch?console.log(`The branch ${JSON.stringify(n.object)} is terminal`):(console.log(`The branch ${JSON.stringify(n.object)} is not terminal`),n.then_branches=this.then_branches),console.log("***"),n.translate_object}return e.node}))}get is_terminal_branch(){return!(this.branches().length&&this.has_then_ranches)&&this.object.every(n=>{return console.log(`item: ${JSON.stringify(n)}`),new Leaf(n).is_string})}translate_branch_reference(n){const e=this.duplicate_branch(this.tree.branch(n.node.branch));console.log(e,this.then_branches,n);const t=new Branch(this.tree,e,this.then_branches);if(n.has_then_reference){console.log("Leaf does have a then reference");const e=this.translate_then_reference(n);console.log(`about to prepend a then_object with length ${e.length}`),t.prepend_then_branch(e),console.log(`After prepending then object, branch ${JSON.stringify(t.object)} shows ${t.then_branches} as then obj`)}return t.translate_object}translate_then_reference(n){console.log(`--${JSON.stringify(n)}`);let e=n.node.then;return"String"===e.constructor.name&&(e=[e]),console.log(`--${JSON.stringify(e)}`),new Branch(this.tree,e).translate_object}duplicate_branch(n){return JSON.parse(JSON.stringify(n))}prepend_then_branch(n){void 0!==n&&(this.has_then_branches?(console.log(`putting ${this.then_branches} inside ${n}`),this.then_branches=[...n,this.then_branches]):(console.log(`Setting empty then branch of ${JSON.stringify(this.object)} to ${n}`),this.then_branches=n))}get has_then_branches(){return void 0!==this.then_branches}}class Leaf{constructor(n){this.node=n}get is_branch(){return Array.isArray(this.node)}get is_string(){return"String"===this.node.constructor.name}get is_branch_reference(){return"object"==typeof this.node&&void 0!==this.node.branch}get has_then_reference(){return"object"==typeof this.node&&void 0!==this.node.then}}module.exports=Tree;