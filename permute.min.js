class Tree{constructor(n){this.object=n}get one(){return this.translated_branch.one()}get permutations(){return this.translated_branch.terminal_leaves()}get translated_branch(){return new Branch(this,this.translate_main)}get translate_main(){return new Branch(this,this.object.main).translate_object}branch(n){return this.object[n]||[]}}class Branch{constructor(n,t,e){this.tree=n,this.object=t,this.then_branches=e}terminal_leaves(n=""){return this.branches().length?this.leaves().reduce((t,e)=>{return t.concat(this.branches().reduce((t,r)=>{return t.concat(new Branch(this.tree,r).terminal_leaves(`${n}${e}`))},[]))},[]):this.leaves().map(t=>`${n}${t}`)}one(n=""){const t=`${n}${this.leaves(!0)}`;return this.branches().length?new Branch(this.tree,this.branches(!0)).one(t):t}leaves(n=!1){let t=this.object.filter(n=>new Leaf(n).is_string)||[];const e=t.length?t:[""];return n?e[~~(e.length*Math.random())]:e}branches(n=!1){const t=this.object.filter(n=>new Leaf(n).is_branch);return n?t[~~(t.length*Math.random())]:t}get translate_object(){const n=new Leaf(this.object);return n.has_directive("branch")?this.translate_branch_reference(n):(this.is_terminal_branch&&void 0!==this.then_branches&&this.object.push(this.then_branches),this.object.map(n=>{const t=new Leaf(n);if(t.has_directive("branch"))return this.translate_branch_reference(t);if(t.is_branch){const n=new Branch(this.tree,t.node);return n.is_terminal_branch||(n.then_branches=this.then_branches),n.translate_object}return t.node}))}get is_terminal_branch(){return!(this.branches().length&&this.has_then_branches)&&this.object.every(n=>new Leaf(n).is_string)}translate_branch_reference(n){const t=this.duplicate_branch(this.tree.branch(n.node.branch)),e=new Branch(this.tree,t,this.then_branches);if(n.has_directive("then")){const t=this.translate_then_reference(n);e.prepend_then_branch(t)}return e.translate_object}translate_then_reference(n){let t=n.node.then;return"String"===t.constructor.name&&(t=[t]),new Branch(this.tree,t).translate_object}duplicate_branch(n){return JSON.parse(JSON.stringify(n))}prepend_then_branch(n){if(void 0!==n){let t=new Branch(this.tree,n,this.then_branches);if(t.is_terminal_branch)return this.has_then_branches?this.then_branches=[...n,this.then_branches]:this.then_branches=n,this.then_branches;{const n=t.branches().map(n=>{return new Branch(this.tree,t,this.then_branches).prepend_then_branch(n)});return this.then_branches=[...t.leaves(),...n],this.then_branches}}}get has_then_branches(){return void 0!==this.then_branches}}class Leaf{constructor(n){this.node=n}get is_branch(){return Array.isArray(this.node)}get is_string(){return"String"===this.node.constructor.name}has_directive(n="branch"){return"object"==typeof this.node&&void 0!==this.node[n]}}module.exports=Tree;