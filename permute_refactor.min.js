class Tree{constructor(e){this.object=e}get permutations(){return new Branch(this,this.translate_main).terminal_leaves()}get translate_main(){return new Branch(this,this.object.main).translate_object}branch(e){return this.object[e]||[]}}class Branch{constructor(e,t){this.tree=e,this.object=t}terminal_leaves(e=""){return this.branches.length?this.leaves.reduce((t,n)=>{return t.concat(this.branches.reduce((t,r)=>{return t.concat(new Branch(this.tree,r).terminal_leaves(`${e}${n}`))},[]))},[]):this.leaves.map(t=>`${e}${t}`)}get leaves(){return this.object.filter(e=>new Leaf(e).is_terminal)}get branches(){return this.object.filter(e=>new Leaf(e).is_branch)}get translate_object(){const e=new Leaf(this.object);return e.is_branch_reference?this.translate_branch_reference(e):this.object.map(e=>{const t=new Leaf(e);return t.is_branch_reference?this.translate_branch_reference(t):t.is_branch?new Branch(this.tree,t.node).translate_object:t.node})}translate_branch_reference(e){const t=this.duplicate_branch(this.tree.branch(e.node.branch));if(e.has_then_reference){const n=this.translate_then_reference(e);t.push(n)}return new Branch(this.tree,t).translate_object}translate_then_reference(e){let t=e.node.then;return"String"===t.constructor.name&&(t=[t]),new Branch(this.tree,t).translate_object}duplicate_branch(e){return JSON.parse(JSON.stringify(e))}}class Leaf{constructor(e){this.node=e}get is_branch(){return Array.isArray(this.node)}get is_terminal(){return"String"===this.node.constructor.name}get is_branch_reference(){return"object"==typeof this.node&&void 0!==this.node.branch}get has_then_reference(){return"object"==typeof this.node&&void 0!==this.node.then}}module.exports=Tree;